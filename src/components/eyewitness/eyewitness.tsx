import { Button, Stack, TextInput, Alert, Group, Title, Card, Table, Text } from "@mantine/core";
import { useForm } from "@mantine/form";
import { useCallback, useState, useEffect, useRef, useMemo } from "react";
import { CommandHelper } from "../../utils/CommandHelper";
import ConsoleWrapper from "../ConsoleWrapper/ConsoleWrapper";
import { SaveOutputToTextFile_v2 } from "../SaveOutputToFile/SaveOutputToTextFile";
import { checkAllCommandsAvailability } from "../../utils/CommandAvailability";
import { LoadingOverlayAndCancelButton } from "../OverlayAndCancelButton/OverlayAndCancelButton";
import { RenderComponent } from "../UserGuide/UserGuide";
import InstallationModal from "../InstallationModal/InstallationModal";

// NEW: Tauri helpers for pickers and opening results
import { open as openDialog } from "@tauri-apps/api/dialog";
import { exists, readTextFile } from "@tauri-apps/api/fs";
import { join, basename } from "@tauri-apps/api/path";
import { open as shellOpen } from "@tauri-apps/api/shell";

/**
 * Represents the form values for the EyeWitness component.
 */
interface FormValuesType {
    filePath: string;
    directory: string;
    timeout: string;
}

/**
 * The Eyewitness component.
 * @returns The Eyewitness component.
 */
const title = "EyeWitness";
const description =
    "EyeWitness takes screenshots of websites, provides information about the server header, and identifies default credentials (if known). It presents this information in a HTML report.";
const steps =
    "Step 1: Create a plain text file on your local drive and add URLs to it. Each URL must be on its own line. Add the file path to the text file in the first field. \n\n" +
    "Step 2: Add the file path for where you want the output saved in the second field.\n\n" +
    "Step 3: Add a number in the third field for the maximum number of seconds for EyeWitness to try and screenshot a webpage, e.g. 20. \n\n" +
    "Step 4: Press the scan button. ";
const sourceLink = "https://www.kali.org/tools/eyewitness/#eyewitness"; // Link to the source code or relevant documentation.
const tutorial = "https://docs.google.com/document/d/1V4lIQbeIbKwNiLQqSXvJZ0HM34q5FDxe2HHP2t6d8mA/edit?usp=sharing"; // Link to the official tutorial/documentation.
const dependencies = ["eyewitness"]; // Dependencies required by the component.

// Simple parser for a clean summary card (optional, additive)
function parseSummary(raw: string) {
    const lines = raw.split(/\r?\n/);
    const get = (rx: RegExp) => (lines.find((l) => rx.test(l)) || "").split(":").slice(1).join(":").trim();
    return {
        Targets: get(/(Input|File|URLs)\s*:/i) || "",
        Output: get(/(Report|Output|Directory)\s*:/i) || "",
        Screenshots: get(/(Screenshots|Captured)\s*:/i) || "",
        Errors: lines.filter((l) => /error/i.test(l)).length.toString(),
    };
}

function Eyewitness() {
    // State Variables
    const [loading, setLoading] = useState(false); // Controls the loading state of the component
    const [output, setOutput] = useState(""); // Stores the output generated by the command
    const [pid, setPid] = useState(""); // Stores the PID of the running command process
    const [allowSave, setAllowSave] = useState(false); // Determines whether saving the output is allowed
    const [hasSaved, setHasSaved] = useState(false); // Indicates whether the output has been saved
    const [isCommandAvailable, setIsCommandAvailable] = useState(false); // State variable to check if the command is available.
    const [opened, setOpened] = useState(!isCommandAvailable); // State variable that indicates if the modal is opened.
    const [loadingModal, setLoadingModal] = useState(true); // State variable to indicate loading state of the modal
    const [showAlert, setShowAlert] = useState(true);
    const alertTimeout = useRef<NodeJS.Timeout | null>(null);

    // NEW: UX & validation state
    const [friendlyError, setFriendlyError] = useState<string | null>(null);
    const [canRun, setCanRun] = useState(false);
    const [resultsPath, setResultsPath] = useState<string | null>(null);

    const form = useForm<FormValuesType>({
        initialValues: {
            filePath: "",
            directory: "",
            timeout: "",
        },
    });

    useEffect(() => {
        // Check if the command is available and set the state variables accordingly.
        checkAllCommandsAvailability(dependencies)
            .then((isAvailable) => {
                setIsCommandAvailable(isAvailable); // Set the command availability state.
                setOpened(!isAvailable); // Set the modal state to opened if the command is not available.
                setLoadingModal(false); // Set loading to false after the check is done.
            })
            .catch((error) => {
                console.error("An error occurred:", error);
                setLoadingModal(false); // Also set loading to false in case of error.
            });
        // Set timeout to remove alert after 5 seconds on load.
        alertTimeout.current = setTimeout(() => {
            setShowAlert(false);
        }, 5000);

        return () => {
            if (alertTimeout.current) {
                clearTimeout(alertTimeout.current);
            }
        };
    }, []);

    const handleShowAlert = () => {
        setShowAlert(true);
        if (alertTimeout.current) {
            clearTimeout(alertTimeout.current);
        }
        alertTimeout.current = setTimeout(() => {
            setShowAlert(false);
        }, 5000);
    };

    /** NEW: File picker for input (.txt) */
    const pickInputFile = async () => {
        const selected = await openDialog({
            multiple: false,
            directory: false,
            filters: [{ name: "Text", extensions: ["txt", "list"] }],
        });
        if (typeof selected === "string") {
            form.setFieldValue("filePath", selected);
            await validatePaths();
        }
    };

    /** NEW: Directory picker for output */
    const pickOutputDir = async () => {
        const selected = await openDialog({ multiple: false, directory: true });
        if (typeof selected === "string") {
            form.setFieldValue("directory", selected);
            await validatePaths();
        }
    };

    /** NEW: Validate inputs and produce friendly errors */
    const validatePaths = useCallback(async () => {
        setFriendlyError(null);
        setCanRun(false);

        const input = form.values.filePath.trim();
        const outdir = form.values.directory.trim();

        if (!input || !outdir) return;

        // input file exists?
        const fileExists = await exists(input);
        if (!fileExists) {
            setFriendlyError(`File not found: ${input}`);
            return;
        }

        // readable + not empty?
        try {
            const content = await readTextFile(input);
            if (!content || content.trim().length === 0) {
                setFriendlyError("Input file is empty");
                return;
            }
        } catch {
            setFriendlyError("Unreadable file (permission denied)");
            return;
        }

        // output dir exists?
        const dirExists = await exists(outdir);
        if (!dirExists) {
            setFriendlyError(`Output folder not found: ${outdir}`);
            return;
        }

        // block same location (common slip)
        try {
            const inputDir = await basename(input);
            const outDirName = await basename(outdir);
            if (input.startsWith(outdir)) {
                setFriendlyError("Input file and output folder cannot be the same location.");
                return;
            }
            // also block if literally equal (unlikely but safe)
            if (input === outdir || inputDir === outDirName) {
                setFriendlyError("Input file and output folder cannot be the same location.");
                return;
            }
        } catch {
            // ignore
        }

        setFriendlyError(null);
        setCanRun(true);
    }, [form.values.filePath, form.values.directory]);

    useEffect(() => {
        // re-validate on changes
        validatePaths();
    }, [form.values.filePath, form.values.directory, validatePaths]);

    // Handles streaming output
    const handleProcessData = useCallback((data: string) => {
        setOutput((prevOutput) => (prevOutput ? prevOutput + "\n" : "") + data);
    }, []);

    // Termination handler with friendly errors + results detection
    const handleProcessTermination = useCallback(
        async ({ code, signal }: { code: number; signal: number }) => {
            if (code === 0) {
                handleProcessData("\nProcess completed successfully.");

                // Try to find a report to open
                try {
                    const outdir = form.values.directory.trim();
                    const indexHtml = await join(outdir, "index.html");
                    const reportHtml = await join(outdir, "report.html");

                    const hasIndex = await exists(indexHtml);
                    const hasReport = !hasIndex && (await exists(reportHtml));

                    if (hasIndex) setResultsPath(indexHtml);
                    else if (hasReport) setResultsPath(reportHtml);
                    else setResultsPath(outdir);

                    setFriendlyError(null);
                } catch {
                    // ignore best-effort report discovery
                }
            } else if (signal === 15) {
                handleProcessData("\nProcess was manually terminated.");
            } else {
                // Friendly mapping using raw output
                const raw = (output || "").toLowerCase();
                if (/permission denied/.test(raw)) setFriendlyError("Unreadable file (permission denied)");
                else if (/no such file|cannot open|not found/.test(raw))
                    setFriendlyError(`File not found: ${form.values.filePath}`);
                else if (/empty file|zero length/.test(raw)) setFriendlyError("Input file is empty");
                else setFriendlyError("Execution failed. Please check inputs and try again.");
            }

            setPid(""); // Clear PID
            setLoading(false); // Cancel overlay
            setAllowSave(true); // Allow save after finalised
            setHasSaved(false); // Reset save status
        },
        [handleProcessData, form.values.directory, form.values.filePath, output]
    );

    // Actions taken after saving the output
    const handleSaveComplete = () => {
        setHasSaved(true);
        setAllowSave(false);
    };

    /**
     * Handles form submission, executes the EyeWitness tool, and updates the state.
     */
    const onSubmit = async (values: FormValuesType) => {
        setAllowSave(false);
        setLoading(true);
        setFriendlyError(null);
        setResultsPath(null);
        setOutput("");

        // final preflight validation
        await validatePaths();
        if (!canRun) {
            setLoading(false);
            return;
        }

        const args = [
            "-f",
            values.filePath,
            "--web",
            "-d",
            values.directory,
            "--timeout",
            `${values.timeout}`,
            "--no-prompt",
        ];

        CommandHelper.runCommandGetPidAndOutput("eyewitness", args, handleProcessData, handleProcessTermination)
            .then(({ pid, output }) => {
                setPid(pid);
                setOutput(output);
            })
            .catch((error) => {
                setLoading(false);
                setFriendlyError("Execution failed. Please try again.");
                setOutput(`Error: ${error.message}`);
            });
    };

    /**
     * Clears the output data and resets the save state.
     */
    const clearOutput = useCallback(() => {
        setOutput("");
        setHasSaved(false);
        setAllowSave(false);
        setFriendlyError(null);
        setResultsPath(null);
    }, []);

    // Simple clean summary (optional, additive)
    const summary = useMemo(() => (output ? parseSummary(output) : null), [output]);

    return (
        <RenderComponent
            title={title}
            description={description}
            steps={steps}
            tutorial={tutorial}
            sourceLink={sourceLink}
        >
            {!loadingModal && (
                <InstallationModal
                    isOpen={opened}
                    setOpened={setOpened}
                    feature_description={description}
                    dependencies={dependencies}
                ></InstallationModal>
            )}
            <form onSubmit={form.onSubmit((values) => onSubmit(values))}>
                {LoadingOverlayAndCancelButton(loading, pid)}
                <Stack>
                    <Group position="right">
                        {!showAlert && (
                            <Button onClick={handleShowAlert} size="xs" variant="outline" color="gray">
                                Show Disclaimer
                            </Button>
                        )}
                    </Group>
                    {showAlert && (
                        <Alert title="Warning: Potential Risks" color="red">
                            This tool is used to perform website enumeration, use with caution and only on targets you
                            own or have explicit permission to test.
                        </Alert>
                    )}

                    <p>{description}</p>

                    {/* Input file with picker */}

                    <Group grow>
                        <TextInput
                            label={"Enter the file name or path containing URLs: "}
                            placeholder={"Example: /home/kali/Deaktop/filename"}
                            required
                            {...form.getInputProps("filePath")}
                            onBlur={validatePaths}
                        />
                        <Button variant="outline" mt={24} onClick={pickInputFile}>
                            Choose File
                        </Button>
                    </Group>

                    {/* Output file with picker */}
                    <Title order={5} mt="md">
                        Output file
                    </Title>
                    <Group grow>
                        <TextInput
                            label={
                                "Enter the directory name where you want to save screenshots or define path of directory"
                            }
                            placeholder={"Example: /home/kali/Desktop name"}
                            required
                            {...form.getInputProps("directory")}
                            onBlur={validatePaths}
                        />
                        <Button variant="outline" mt={24} onClick={pickOutputDir}>
                            Choose Folder
                        </Button>
                    </Group>

                    <TextInput
                        label={"Timeout (seconds)"}
                        placeholder={"e.g. 20"}
                        required
                        {...form.getInputProps("timeout")}
                    />

                    {friendlyError && (
                        <Alert color="red" mt="sm">
                            {friendlyError}
                        </Alert>
                    )}

                    {/* Optional clean summary card */}
                    {output && !friendlyError && summary && (
                        <Card withBorder radius="md" padding="md">
                            <Title order={5} mb="sm">
                                Summary
                            </Title>
                            <Table withTableBorder withColumnBorders>
                                <Table.Tbody>
                                    {Object.entries(summary).map(([k, v]) => {
                                        if (!v) return null;
                                        return (
                                            <Table.Tr key={k}>
                                                <Table.Td width="30%">
                                                    <Text fw={600}>{k}</Text>
                                                </Table.Td>
                                                <Table.Td>
                                                    <Text style={{ whiteSpace: "pre-wrap" }}>{v}</Text>
                                                </Table.Td>
                                            </Table.Tr>
                                        );
                                    })}
                                </Table.Tbody>
                            </Table>
                        </Card>
                    )}

                    {/* Save, Run, Open results */}
                    {SaveOutputToTextFile_v2(output, allowSave, hasSaved, handleSaveComplete)}

                    <Button type={"submit"} disabled={!canRun}>
                        Scan
                    </Button>
                    {resultsPath && (
                        <Button
                            variant="light"
                            onClick={() => shellOpen(resultsPath)}
                            title="Open EyeWitness results"
                            mt="sm"
                        >
                            Open results
                        </Button>
                    )}

                    {/* Raw output console (your existing wrapper; now bigger & resizable if you used the updated ConsoleWrapper) */}
                    <ConsoleWrapper output={output} clearOutputCallback={clearOutput} />
                </Stack>
            </form>
        </RenderComponent>
    );
}
export default Eyewitness;
